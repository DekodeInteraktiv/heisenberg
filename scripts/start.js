'use strict';

/**
 * Do this as the first thing so that any code reading it knows the right env.
 */
process.env.NODE_ENV = 'development';

/**
 * Makes the script crash on unhandled rejections instead of silently
 * ignoring them.
 */
process.on( 'unhandledRejection', err => {
	throw err;
});

/**
 * External dependencies
 */
const _ = require( 'lodash' );
const chalk = require( 'chalk' );
const clearConsole = require( 'react-dev-utils/clearConsole' );
const createWebpackCompiler = require( './utils/create-webpack-compiler' );
const detect = require( 'detect-port' );
const getProcessForPort = require( 'react-dev-utils/getProcessForPort' );
const prompt = require( 'react-dev-utils/prompt' );
const validator = require( 'validator' );
const WebpackDevServer = require( 'webpack-dev-server' );

/**
 * Internal dependencies
 */
const config = require( '../config/webpack.config.dev' );
const devServerConfig = require( '../config/webpackDevServer.config' );
const paths = require( '../config/paths' );

/**
 * Variables
 */
const isInteractive = process.stdout.isTTY;
const proxy = _.trim( require( paths.appPackageJson ).proxy );
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;

/**
 * Check if proxy url is valid
 */
if ( ! proxy ) {
	console.log();
	console.log( chalk.red( 'The `proxy` field is not defined in your `package.json`' ) );
	console.log();
	process.exit( 1 );
}

if ( ! validator.isURL( proxy, { require_protocol: true } ) ) {
	console.log();
	console.log( chalk.red( 'The proxy is not a valid url' ) );
	console.log();
	process.exit( 1 );
}

function run( port ) {
	// Variables
	const host = process.env.HOST || 'localhost';

	detect( 3100 ).then( devPort => {
		/**
		 * Create a webpack compiler that is configured with custom messages.
		 */
		const compiler = createWebpackCompiler(
			port,
			devPort,
			config( devPort ),
			function onReady( showInstructions ) {
				if ( ! showInstructions ) {
					return;
				}

				console.log();
				console.log( 'The site is running at:' );
				console.log();
				console.log( `  ${chalk.cyan( `http://${host}:${port}/` )}  ${chalk.dim( `(${proxy})` )}` );
				console.log();
				console.log( 'Note that the development build is not optimized.' );
				console.log(
					`To create a production build, use ${chalk.cyan( 'yarn build' )}.`
				);
				console.log();
			}
		);

		// Serve webpack assets generated by the compiler over a web sever.
		const devServer = new WebpackDevServer( compiler, devServerConfig );

		// Launch WebpackDevServer.
		devServer.listen( devPort, host, err => {
			if ( err ) {
				return console.log( err );
			}

			if ( isInteractive ) {
				clearConsole();
			}

			console.log( chalk.cyan( 'Starting the development server...' ) );
			console.log();
		});
	});
}

// We attempt to use the default port but if it is busy, we offer the user to
// run on a different port. `detect()` Promise resolves to the next free port.
detect( DEFAULT_PORT ).then( port => {
	if ( port === DEFAULT_PORT ) {
		run( port );
		return;
	}

	if ( isInteractive ) {
		clearConsole();
		const existingProcess = getProcessForPort( DEFAULT_PORT );
		const question = chalk.yellow(
			`Something is already running on port ${DEFAULT_PORT}.` +
			`${existingProcess ? ` Probably:\n  ${existingProcess}` : ''}`
		) + '\n\nWould you like to run the app on another port instead?';

		prompt( question, true ).then( shouldChangePort => {
			if ( shouldChangePort ) {
				run( port );
			}
		});
	} else {
		console.log(
			chalk.red(`Something is already running on port ${DEFAULT_PORT}.`)
		);
	}
});
